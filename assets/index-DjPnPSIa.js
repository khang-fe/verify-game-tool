/*! noble-secp256k1 - MIT License (c) 2019 Paul Miller (paulmillr.com) */const R={p:0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2fn,n:0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141n,h:1n,a:0n,b:7n,Gx:0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798n,Gy:0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8n},{p:Z,n:$,Gx:nt,Gy:et,b:M}=R,U=32,G=64,st={publicKey:U+1,publicKeyUncompressed:G+1},ft=(...t)=>{"captureStackTrace"in Error&&typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(...t)},b=(t="")=>{const n=new Error(t);throw ft(n,b),n},rt=t=>typeof t=="bigint",ot=t=>typeof t=="string",ct=t=>t instanceof Uint8Array||ArrayBuffer.isView(t)&&t.constructor.name==="Uint8Array",V=(t,n,e="")=>{const f=ct(t),r=t?.length,o=n!==void 0;if(!f||o&&r!==n){const i=e&&`"${e}" `,u=o?` of length ${n}`:"",c=f?`length=${r}`:`type=${typeof t}`;b(i+"expected Uint8Array"+u+", got "+c)}return t},O=t=>new Uint8Array(t),j=(t,n)=>t.toString(16).padStart(n,"0"),W=t=>Array.from(V(t)).map(n=>j(n,2)).join(""),A={_0:48,_9:57,A:65,F:70,a:97,f:102},z=t=>{if(t>=A._0&&t<=A._9)return t-A._0;if(t>=A.A&&t<=A.F)return t-(A.A-10);if(t>=A.a&&t<=A.f)return t-(A.a-10)},D=t=>{const n="hex invalid";if(!ot(t))return b(n);const e=t.length,f=e/2;if(e%2)return b(n);const r=O(f);for(let o=0,i=0;o<f;o++,i+=2){const u=z(t.charCodeAt(i)),c=z(t.charCodeAt(i+1));if(u===void 0||c===void 0)return b(n);r[o]=u*16+c}return r},C=(...t)=>{const n=O(t.reduce((f,r)=>f+V(r).length,0));let e=0;return t.forEach(f=>{n.set(f,e),e+=f.length}),n},N=BigInt,X=(t,n,e,f="bad number: out of range")=>rt(t)&&n<=t&&t<e?t:b(f),s=(t,n=Z)=>{const e=t%n;return e>=0n?e:n+e},it=(t,n)=>{(t===0n||n<=0n)&&b("no inverse n="+t+" mod="+n);let e=s(t,n),f=n,r=0n,o=1n;for(;e!==0n;){const i=f/e,u=f%e,c=r-o*i;f=e,e=u,r=o,o=c}return f===1n?s(r,n):b("no inverse")},k=t=>t instanceof h?t:b("Point expected"),J=t=>s(s(t*t)*t+M),H=t=>X(t,0n,Z),S=t=>X(t,1n,Z),at=t=>X(t,1n,$),F=t=>(t&1n)===0n,Q=t=>Uint8Array.of(t),ut=t=>Q(F(t)?2:3),lt=t=>{const n=J(S(t));let e=1n;for(let f=n,r=(Z+1n)/4n;r>0n;r>>=1n)r&1n&&(e=e*f%Z),f=f*f%Z;return s(e*e)===n?e:b("sqrt invalid")};class h{static BASE;static ZERO;X;Y;Z;constructor(n,e,f){this.X=H(n),this.Y=S(e),this.Z=H(f),Object.freeze(this)}static CURVE(){return R}static fromAffine(n){const{x:e,y:f}=n;return e===0n&&f===0n?B:new h(e,f,1n)}static fromBytes(n){V(n);const{publicKey:e,publicKeyUncompressed:f}=st;let r;const o=n.length,i=n[0],u=n.subarray(1),c=I(u,0,U);if(o===e&&(i===2||i===3)){let d=lt(c);const a=F(d);F(N(i))!==a&&(d=s(-d)),r=new h(c,d,1n)}return o===f&&i===4&&(r=new h(c,I(u,U,G),1n)),r?r.assertValidity():b("bad point: not on curve")}static fromHex(n){return h.fromBytes(D(n))}get x(){return this.toAffine().x}get y(){return this.toAffine().y}equals(n){const{X:e,Y:f,Z:r}=this,{X:o,Y:i,Z:u}=k(n),c=s(e*u),d=s(o*r),a=s(f*u),w=s(i*r);return c===d&&a===w}is0(){return this.equals(B)}negate(){return new h(this.X,s(-this.Y),this.Z)}double(){return this.add(this)}add(n){const{X:e,Y:f,Z:r}=this,{X:o,Y:i,Z:u}=k(n),c=0n,d=M;let a=0n,w=0n,y=0n;const v=s(d*3n);let p=s(e*o),x=s(f*i),g=s(r*u),Y=s(e+f),l=s(o+i);Y=s(Y*l),l=s(p+x),Y=s(Y-l),l=s(e+r);let m=s(o+u);return l=s(l*m),m=s(p+g),l=s(l-m),m=s(f+r),a=s(i+u),m=s(m*a),a=s(x+g),m=s(m-a),y=s(c*l),a=s(v*g),y=s(a+y),a=s(x-y),y=s(x+y),w=s(a*y),x=s(p+p),x=s(x+p),g=s(c*g),l=s(v*l),x=s(x+g),g=s(p-g),g=s(c*g),l=s(l+g),p=s(x*l),w=s(w+p),p=s(m*l),a=s(Y*a),a=s(a-p),p=s(Y*x),y=s(m*y),y=s(y+p),new h(a,w,y)}subtract(n){return this.add(k(n).negate())}multiply(n,e=!0){if(!e&&n===0n)return B;if(at(n),n===1n)return this;if(this.equals(E))return ht(n).p;let f=B,r=E;for(let o=this;n>0n;o=o.double(),n>>=1n)n&1n?f=f.add(o):e&&(r=r.add(o));return f}multiplyUnsafe(n){return this.multiply(n,!1)}toAffine(){const{X:n,Y:e,Z:f}=this;if(this.equals(B))return{x:0n,y:0n};if(f===1n)return{x:n,y:e};const r=it(f,Z);return s(f*r)!==1n&&b("inverse invalid"),{x:s(n*r),y:s(e*r)}}assertValidity(){const{x:n,y:e}=this.toAffine();return S(n),S(e),s(e*e)===J(n)?this:b("bad point: not on curve")}toBytes(n=!0){const{x:e,y:f}=this.assertValidity().toAffine(),r=K(e);return n?C(ut(f),r):C(Q(4),r,K(f))}toHex(n){return W(this.toBytes(n))}}const E=new h(nt,et,1n),B=new h(0n,1n,0n);h.BASE=E;h.ZERO=B;const P=t=>N("0x"+(W(t)||"0")),I=(t,n,e)=>P(t.subarray(n,e)),dt=2n**256n,K=t=>D(j(X(t,0n,dt),G)),yt=t=>{const n=P(V(t,U,"secret key"));return X(n,1n,$,"invalid secret key: outside of range")},xt=(t,n,e=!0)=>h.fromBytes(n).multiply(yt(t)).toBytes(e),T=8,pt=256,tt=Math.ceil(pt/T)+1,q=2**(T-1),bt=()=>{const t=[];let n=E,e=n;for(let f=0;f<tt;f++){e=n,t.push(e);for(let r=1;r<q;r++)e=e.add(n),t.push(e);n=e.double()}return t};let _;const L=(t,n)=>{const e=n.negate();return t?e:n},ht=t=>{const n=_||(_=bt());let e=B,f=E;const r=2**T,o=r,i=N(r-1),u=N(T);for(let c=0;c<tt;c++){let d=Number(t&i);t>>=u,d>q&&(d-=o,t+=1n);const a=c*q,w=a,y=a+Math.abs(d)-1,v=c%2!==0,p=d<0;d===0?f=f.add(L(v,n[w])):e=e.add(L(p,n[y]))}return t!==0n&&b("invalid wnaf"),{p:e,f}};export{h as Point,xt as getSharedSecret};
