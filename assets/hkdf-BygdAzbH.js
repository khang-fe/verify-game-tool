import{a as H,b as p,c as y,d as f,e as w}from"./utils-x7Ec7zCf.js";class b{oHash;iHash;blockLen;outputLen;finished=!1;destroyed=!1;constructor(t,e){if(H(t),p(e,void 0,"key"),this.iHash=t.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const o=this.blockLen,s=new Uint8Array(o);s.set(e.length>o?t.create().update(e).digest():e);for(let i=0;i<s.length;i++)s[i]^=54;this.iHash.update(s),this.oHash=t.create();for(let i=0;i<s.length;i++)s[i]^=106;this.oHash.update(s),y(s)}update(t){return f(this),this.iHash.update(t),this}digestInto(t){f(this),p(t,this.outputLen,"output"),this.finished=!0,this.iHash.digestInto(t),this.oHash.update(t),this.oHash.digestInto(t),this.destroy()}digest(){const t=new Uint8Array(this.oHash.outputLen);return this.digestInto(t),t}_cloneInto(t){t||=Object.create(Object.getPrototypeOf(this),{});const{oHash:e,iHash:o,finished:s,destroyed:i,blockLen:c,outputLen:r}=this;return t=t,t.finished=s,t.destroyed=i,t.blockLen=c,t.outputLen=r,t.oHash=e._cloneInto(t.oHash),t.iHash=o._cloneInto(t.iHash),t}clone(){return this._cloneInto()}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const l=(n,t,e)=>new b(n,t).update(e).digest();l.create=(n,t)=>new b(n,t);function g(n,t,e){return H(n),e===void 0&&(e=new Uint8Array(n.outputLen)),l(n,e,t)}const u=Uint8Array.of(0),L=Uint8Array.of();function I(n,t,e,o=32){H(n),w(o,"length");const s=n.outputLen;if(o>255*s)throw new Error("Length must be <= 255*HashLen");const i=Math.ceil(o/s);e===void 0?e=L:p(e,void 0,"info");const c=new Uint8Array(i*s),r=l.create(n,t),h=r._cloneInto(),d=new Uint8Array(r.outputLen);for(let a=0;a<i;a++)u[0]=a+1,h.update(a===0?L:d).update(e).update(u).digestInto(d),c.set(d,s*a),r._cloneInto(h);return r.destroy(),h.destroy(),y(d,u),c.slice(0,o)}const x=(n,t,e,o,s)=>I(n,g(n,t,e),o,s);export{I as expand,g as extract,x as hkdf};
